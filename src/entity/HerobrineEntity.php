<?php

/*
 *   _    _                _          _
 *  | |  | |              | |        (_)
 *  | |__| | ___ _ __ ___ | |__  _ __ _ _ __   ___
 *  |  __  |/ _ \ '__/ _ \| '_ \| '__| | '_ \ / _ \
 *  | |  | |  __/ | | (_) | |_) | |  | | | | |  __/
 *  |_|  |_|\___|_|  \___/|_.__/|_|  |_|_| |_|\___|
 *
 * Copyright (C) 2024 pixelwhiz
 *
 * This software is distributed under "GNU General Public License v3.0".
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License v3.0
 * along with this program. If not, see <https://opensource.org/licenses/GPL-3.0>.
 */

namespace pixelwhiz\herobrine\entity;

use pixelwhiz\herobrine\Herobrine;
use pixelwhiz\herobrine\sessions\EntityManager;
use pixelwhiz\herobrine\sessions\EntitySession;
use pixelwhiz\herobrine\libs\apibossbar\BossBar;
use pixelwhiz\herobrine\libs\apibossbar\DiverseBossBar;
use pixelwhiz\herobrine\utils\Sound;
use pixelwhiz\herobrine\utils\Weather;
use pocketmine\block\utils\MobHeadType;
use pocketmine\block\VanillaBlocks;
use pocketmine\entity\Human;
use pocketmine\entity\Location;
use pocketmine\entity\object\ExperienceOrb;
use pocketmine\entity\object\FallingBlock;
use pocketmine\entity\object\ItemEntity;
use pocketmine\entity\object\Painting;
use pocketmine\entity\object\PaintingMotive;
use pocketmine\entity\object\PrimedTNT;
use pocketmine\entity\Skin;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\item\Item;
use pocketmine\item\VanillaItems;
use pocketmine\math\Vector3;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\network\mcpe\protocol\types\entity\EntityMetadataProperties;
use pocketmine\network\mcpe\protocol\types\entity\StringMetadataProperty;
use pocketmine\player\GameMode;
use pocketmine\player\Player;
use pocketmine\Server;
use pocketmine\world\particle\EndermanTeleportParticle;
use pocketmine\world\sound\EndermanTeleportSound;
use function PHPUnit\Framework\isNull;

class HerobrineEntity extends Human {
    use EntityManager;
    use EntitySession;
    use EntityAbilitiesTrait;

    public BossBar $bar;
    public int $phase = 0;

    public bool $isInGame = false;

    public int $startTime = 20 * 10;

    public int $startSession = 20;
    public int $gameSession = 20;

    public function __construct(Location $location, Skin $skin, ?CompoundTag $nbt = null)
    {
        parent::__construct($location, $skin, $nbt);
        $this->bar = new BossBar();
    }


    public function setPhase(int $currentPhase): void {
        if ($currentPhase < 0) {
            throw new \InvalidArgumentException("Phase cannot be negative");
        }

        $this->phase = $currentPhase;
    }

    public function getPhase() : int {
        return $this->phase;
    }



    public function getNameTag(): string
    {
        return "Herobrine";
    }

    public function teleport(Vector3 $pos, ?float $yaw = null, ?float $pitch = null): bool
    {
        $this->getWorld()->addSound($pos->asVector3(), new EndermanTeleportSound(), $this->getWorld()->getPlayers());
        $this->getWorld()->addParticle($pos, new EndermanTeleportParticle(), $this->getWorld()->getPlayers());
        return parent::teleport($pos, $yaw, $pitch); // TODO: Change the autogenerated stub
    }

    public function getMaxHealth(): int
    {
        return 200;
    }

    protected function entityBaseTick(int $tickDiff = 1): bool
    {
        $this->handleWeather();
        $this->handleBossBar();

        if ($this->getPhase() === $this->PHASE_START()) {
            $this->bar->setPercentage($this->bar->getPercentage() + 1 / $this->getMaxHealth());
            $this->startTime--;
            $this->startSession--;
            $this->startSession($this);
        }

        if ($this->getPhase() === $this->PHASE_GAME()) {
            $this->gameSession--;
            $this->gameSession($this);
            $this->bar->setPercentage($this->getHealth() / $this->getMaxHealth());

            $this->look();
            $this->normalAttack();

//            $this->doNormalBehavior();
//            if ($this->doNormalBehavior()) {
//                $path = $this->findPath();
//                $this->move($path["x"], $path["y"], $path["z"]);
//            }

            $this->doRandomTeleport();

            if (!$this->isInGame) {
                $this->gameSession($this);
            }
        }

        return parent::entityBaseTick($tickDiff);
    }

    public function sendData(?array $targets, ?array $data = null): void
    {
        $targets = $targets ?? $this->hasSpawned;
        $data = $data ?? $this->getAllNetworkData();
        if(!isset($data[EntityMetadataProperties::NAMETAG])){
            parent::sendData($targets, $data);
            return;
        }
        foreach($targets as $p){
            $data[EntityMetadataProperties::NAMETAG] = new StringMetadataProperty($this->getNameTag());
            $p->getNetworkSession()->getEntityEventBroadcaster()->syncActorData([$p->getNetworkSession()], $this, $data);
        }

        $this->bar->setTitle($this->getNameTag());
        $this->bar->setPercentage(0);
    }

    protected function initEntity(CompoundTag $nbt): void
    {
        parent::initEntity($nbt);

        $this->phase = $nbt->getInt("Phase");

    }

    public function saveNBT(): CompoundTag
    {
        $nbt = parent::saveNBT();
        $nbt->setInt("Phase", $this->phase);
        return $nbt;
    }


    public function attack(EntityDamageEvent $source): void
    {

        if ($source instanceof EntityDamageByEntityEvent) {
            $damager = $source->getDamager();
            if ($damager instanceof Player) {
                $this->bar->addPlayer($damager);
            }
            $source->setKnockBack(0);
        }

        if ($source->getCause() === EntityDamageEvent::CAUSE_FIRE ||
            $source->getCause() === EntityDamageEvent::CAUSE_FIRE_TICK ||
            $source->getCause() === EntityDamageEvent::CAUSE_LAVA ||
            $source->getCause() === EntityDamageEvent::CAUSE_ENTITY_EXPLOSION ||
            $source->getCause() === EntityDamageEvent::CAUSE_BLOCK_EXPLOSION ||
            $source->getCause() === EntityDamageEvent::CAUSE_FALL
        ) {
            $source->cancel();
            return;
        }

        if ($this->getPhase() === $this->PHASE_START()) {
            $source->cancel();
        }

        parent::attack($source);
    }

    protected function onDeath(): void
    {
        foreach ($this->getWorld()->getPlayers() as $player) {
            $this->bar->removePlayer($player);
        }

        if ($this->getHealth() <= 0) {
            Weather::clear($this->getWorld());
            Weather::resetTime($this->getWorld());
        }

        foreach ($this->getDrops() as $item) {
            if ($item instanceof Item) {
                $this->getWorld()->dropItem($this->getPosition()->asVector3(), $item);
            }
        }

        $this->getWorld()->dropExperience($this->getPosition()->asVector3(), 12000);

        Sound::playSound($this, Sound::MOB_WITHER_DEATH);
        parent::onDeath();
    }

    public function getDrops(): array {
        $item = [
            VanillaBlocks::MOB_HEAD()->setMobHeadType(MobHeadType::PLAYER)->asItem(),
        ];
        return $item;
    }

    public function getNearestEntity(int $maxDistance): array {
        $nearestEntity = null;
        $closestDistance = PHP_INT_MAX;

        foreach($this->getWorld()->getEntities() as $entity) {
            $distance = $this->location->distance($entity->getLocation());

            if($distance < $closestDistance && $distance <= $maxDistance) {
                if (!$entity instanceof HerobrineEntity and !$entity instanceof SkullEntity and !$entity instanceof HerobrineHead) {

                    if ($entity instanceof Player and $entity->getGamemode() === GameMode::CREATIVE or
                        $entity instanceof Player and $entity->getGamemode() === GameMode::SPECTATOR or
                        $entity instanceof ExperienceOrb or $entity instanceof FallingBlock or $entity instanceof ItemEntity or $entity instanceof Painting or $entity instanceof PaintingMotive or $entity instanceof PrimedTNT
                    ) continue;

                    $nearestEntity = $entity;
                    $closestDistance = $distance;
                }
            }
        }

        return ['entity' => $nearestEntity, 'distance' => $closestDistance];
    }


}