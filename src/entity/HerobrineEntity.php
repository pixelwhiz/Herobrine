<?php

/*
 *   _    _                _          _
 *  | |  | |              | |        (_)
 *  | |__| | ___ _ __ ___ | |__  _ __ _ _ __   ___
 *  |  __  |/ _ \ '__/ _ \| '_ \| '__| | '_ \ / _ \
 *  | |  | |  __/ | | (_) | |_) | |  | | | | |  __/
 *  |_|  |_|\___|_|  \___/|_.__/|_|  |_|_| |_|\___|
 *
 * Copyright (C) 2024 pixelwhiz
 *
 * This software is distributed under "GNU General Public License v3.0".
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License v3.0
 * along with this program. If not, see <https://opensource.org/licenses/GPL-3.0>.
 */

namespace pixelwhiz\herobrine\entity;

use pixelwhiz\herobrine\Herobrine;
use pixelwhiz\herobrine\sessions\EntityManager;
use pixelwhiz\herobrine\sessions\EntitySession;
use pixelwhiz\herobrine\libs\apibossbar\BossBar;
use pixelwhiz\herobrine\utils\Sound;
use pixelwhiz\herobrine\utils\Weather;
use pixelwhiz\resinapi\ResinAPI;
use pocketmine\block\Liquid;
use pocketmine\block\utils\MobHeadType;
use pocketmine\block\VanillaBlocks;
use pocketmine\entity\Human;
use pocketmine\entity\Location;
use pocketmine\entity\object\ExperienceOrb;
use pocketmine\entity\object\FallingBlock;
use pocketmine\entity\object\ItemEntity;
use pocketmine\entity\object\Painting;
use pocketmine\entity\object\PaintingMotive;
use pocketmine\entity\object\PrimedTNT;
use pocketmine\entity\Skin;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\math\Vector3;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\network\mcpe\protocol\types\entity\EntityMetadataProperties;
use pocketmine\network\mcpe\protocol\types\entity\StringMetadataProperty;
use pocketmine\player\Player;
use pocketmine\world\particle\EndermanTeleportParticle;
use pocketmine\world\sound\EndermanTeleportSound;

class HerobrineEntity extends Human {

    use EntityManager;
    use EntitySession;
    use EntityAbilitiesTrait;

    public BossBar $bar;
    public int $phase = 0;

    public array $spawnPosition = [];
    public array $playerReward = [];

    public bool $isInGame = false;

    public int $startTime = 20;
    public int $gameTime = 20;
    public int $endTime = 20 * 60;

    public function __construct(Location $location, Skin $skin, ?CompoundTag $nbt = null)
    {
        parent::__construct($location, $skin, $nbt);
        $this->bar = new BossBar();
    }

    public function setPhase(int $currentPhase): void {
        if ($currentPhase < 0) {
            throw new \InvalidArgumentException("Phase cannot be negative");
        }

        $this->phase = $currentPhase;
    }

    public function getPhase() : int {
        return $this->phase;
    }

    public function teleport(Vector3 $pos, ?float $yaw = null, ?float $pitch = null): bool
    {
        if ($this->getPhase() === $this->PHASE_GAME()) {
            $this->getWorld()->addSound($pos->asVector3(), new EndermanTeleportSound(), $this->getWorld()->getPlayers());
            $this->getWorld()->addParticle($pos, new EndermanTeleportParticle(), $this->getWorld()->getPlayers());
        }
        return parent::teleport($pos, $yaw, $pitch); // TODO: Change the autogenerated stub
    }

    public function getMaxHealth(): int
    {
        return 200;
    }

    public function jump(): void
    {
        if ($this->isOnGround() or $this->getWorld()->getBlock($this->location) instanceof Liquid) {
            $this->motion = $this->motion->withComponents(null, $this->jumpVelocity, null);
        }

        parent::jump();
    }

    protected function entityBaseTick(int $tickDiff = 1): bool
    {
        $this->handleWeather();
        $this->handleBossBar();
        $this->getHungerManager()->setSaturation(20);
        $this->getHungerManager()->setFood(20);
        $this->setSkin($this->getSkin());

        if ($this->getPhase() === $this->PHASE_START()) {
            $this->setNameTag("Herobrine");
            $this->bar->setPercentage($this->bar->getPercentage() + 1 / $this->getMaxHealth());
            $this->startTime--;
            $this->startSession($this);
        }

        if ($this->getPhase() === $this->PHASE_GAME()) {
            $this->gameTime--;
            $this->setNameTag("Herobrine");
            $this->gameSession($this);
            $this->bar->setPercentage($this->getHealth() / $this->getMaxHealth());
            
            $this->look();
            $this->normalAttack();
            $this->sneak();
            $this->randomMove();
            $this->doRandomTeleport();

            if (!$this->isInGame) {
                $this->gameSession($this);
            }
        }

        if ($this->getPhase() === $this->PHASE_END()) {
            $this->endTime--;
            $this->endSession($this);
        }

        return parent::entityBaseTick($tickDiff);
    }

    public function sendData(?array $targets, ?array $data = null): void
    {
        $targets = $targets ?? $this->hasSpawned;
        $data = $data ?? $this->getAllNetworkData();
        if(!isset($data[EntityMetadataProperties::NAMETAG])){
            parent::sendData($targets, $data);
            return;
        }
        foreach($targets as $p){
            $data[EntityMetadataProperties::NAMETAG] = new StringMetadataProperty($this->getNameTag());
            $p->getNetworkSession()->getEntityEventBroadcaster()->syncActorData([$p->getNetworkSession()], $this, $data);
        }

        $this->bar->setTitle($this->getNameTag());
        $this->bar->setPercentage(0);
    }

    protected function initEntity(CompoundTag $nbt): void
    {
        parent::initEntity($nbt);

        $this->phase = $nbt->getInt("Phase");

    }

    public function saveNBT(): CompoundTag
    {
        $nbt = parent::saveNBT();
        $nbt->setInt("Phase", $this->phase);
        return $nbt;
    }

    public function attack(EntityDamageEvent $source): void
    {
        if ($source instanceof EntityDamageByEntityEvent) {
            $damager = $source->getDamager();
            if ($this->getPhase() === $this->PHASE_GAME()) {
                if ($damager instanceof Player) {
                    $this->bar->addPlayer($damager);
                }

                Sound::playSound($this, Sound::MOB_WITHER_AMBIENT);
                $source->setKnockBack(0);
            }

            if ($this->getPhase() === $this->PHASE_END()) {
                if ($damager instanceof Player) {
                    ResinAPI::getInstance()->sendInvoice(
                        $damager,
                        function (Player $player, string $resinType, int $amount) {
                            $player->sendMessage("Successfully used $amount of $resinType!");
                        },
                    );
                }
            }
        }

        if ($source->getCause() === EntityDamageEvent::CAUSE_FIRE ||
            $source->getCause() === EntityDamageEvent::CAUSE_FIRE_TICK ||
            $source->getCause() === EntityDamageEvent::CAUSE_LAVA ||
            $source->getCause() === EntityDamageEvent::CAUSE_ENTITY_EXPLOSION ||
            $source->getCause() === EntityDamageEvent::CAUSE_BLOCK_EXPLOSION ||
            $source->getCause() === EntityDamageEvent::CAUSE_DROWNING ||
            $source->getCause() === EntityDamageEvent::CAUSE_FALL
        ) {
            $source->cancel();
            return;
        }

        if ($this->getPhase() === $this->PHASE_START() ||
            $this->getPhase() === $this->PHASE_END()
        ) {
            $source->cancel();
        }

        /**
         * IMPLEMENT HEROBRINE DEATH
         */

        if ($source->getFinalDamage() >= $this->getHealth()) {
            $source->cancel();
            $this->setPhase($this->PHASE_END());

            foreach ($this->getWorld()->getPlayers() as $player) {
                $this->bar->removePlayer($player);
            }

            $dataFolder = Herobrine::getInstance()->getDataFolder() . "data/";
            $filePath = $dataFolder . "position.json";
            if (file_exists($filePath)) {
                $positions = json_decode(file_get_contents($filePath), true);

                if (is_array($positions)) {
                    $updatedPositions = array_filter($positions, function ($position) {
                        return !(
                            $position['world'] === $this->getWorld()->getFolderName()
                        );
                    });

                    file_put_contents($filePath, json_encode(array_values($updatedPositions), JSON_PRETTY_PRINT));
                }
            }

            $this->setHealth($this->getMaxHealth());

            $this->sendLightning();
            Weather::clear($this->getWorld());
            Sound::playSound($this, Sound::MOB_WITHER_DEATH);
        }

        parent::attack($source);
    }

    protected function onDeath(): void
    {

        foreach ($this->getWorld()->getPlayers() as $player) {
            $this->bar->removePlayer($player);
        }

        $dataFolder = Herobrine::getInstance()->getDataFolder() . "data/";
        $filePath = $dataFolder . "position.json";
        if (file_exists($filePath)) {
            $positions = json_decode(file_get_contents($filePath), true);

            if (is_array($positions)) {
                $updatedPositions = array_filter($positions, function ($position) {
                    return !(
                        $position['world'] === $this->getWorld()->getFolderName()
                    );
                });

                file_put_contents($filePath, json_encode(array_values($updatedPositions), JSON_PRETTY_PRINT));
            }
        }

        $this->sendLightning();
        Weather::clear($this->getWorld());
        Sound::playSound($this, Sound::MOB_WITHER_DEATH);
        parent::onDeath();
    }

    public function getDrops(): array {
        $item = [
            VanillaBlocks::MOB_HEAD()->setMobHeadType(MobHeadType::PLAYER)->asItem(),
        ];
        return $item;
    }

    public function getNearestEntity(int $maxDistance): array {
        $nearestEntity = null;
        $closestDistance = PHP_INT_MAX;

        foreach($this->getWorld()->getEntities() as $entity) {
            $distance = $this->location->distance($entity->getLocation());

            if($distance < $closestDistance && $distance <= $maxDistance) {
                if (!$entity instanceof HerobrineEntity and !$entity instanceof SkullEntity and !$entity instanceof HerobrineHead) {

                    if (
                        $entity instanceof ExperienceOrb or $entity instanceof FallingBlock or $entity instanceof ItemEntity or $entity instanceof Painting or $entity instanceof PaintingMotive or $entity instanceof PrimedTNT
                    ) continue;

                    $nearestEntity = $entity;
                    $closestDistance = $distance;
                }
            }
        }

        return ['entity' => $nearestEntity, 'distance' => $closestDistance];
    }


}